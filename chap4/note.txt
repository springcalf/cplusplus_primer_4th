	数组的维数必须用值大于等于 1 的常量表达式定义（第 2.7 节）。此常量表达式只能包含整型字面值常量、枚举常量（第 2.7 节）或者用常量表达式初始化的整型 const 对象。非 const 变量以及要到运行阶段才知道其值的 const变量都不能用于定义数组的维数。
	
	如果没有显式提供元素初值，则数组元素会像普通变量一样初始化（第 2.3.4
节）：
	• 在函数体外定义的内置数组，其元素均初始化为 0。
	• 在函数体内定义的内置数组，其元素无初始化。
	•不管数组在哪里定义，如果其元素为类类型，则自动调用该类的默认构造函数进行初始化；如果该类没有默认构造函数，则必须为该数组的元素提供显式初始化。
	
	
	使用一组字符字面值初始化字符数组时，一定要记得添加结束字符串的空字符
	const char ch3[6] = "Daniel"; // error: Daniel is 7 elements
	不允许数组直接复制和赋值
	
	在用下标访问元素时，vector 使用 vector::size_type 作为下标的类型，而数组下标的正确类型则是 size_t（第 3.5.2 节）。
	
	一个有效的指针必然是以下三种状态之一：保存一个特定对象的地址；指向某个对象后面的另一对象；或者是0值。若指针保存0值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它
	
	
	预处理器变量不是在 std 命名空间中定义的，因此其名字应为NULL，而非 std::NULL。
	
	C++ 提供了一种特殊的指针类型 void*，它可以保存任何类型对象的地址
	
	void* 指针只支持几种有限的操作：与另一个指针进行比较；向函数传递void* 指针或从函数返回void* 指针；给另一个 void* 指针赋值。不允许使用void* 指针操纵它所指向的对象
	
	
	第一个区别在于引用总是指向某个对象：定义引用时没有初始化是错误的。第二个重要区别则是赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就始终指向同一个特定对象（这就是为什么引用必须在定义时初始化的原因）。
	
	
	特别是在表达式中使用数组名时，该名字会自动转换为指向数组第一个元素的指针
	的算术操作只有在原指针和计算出来的新指针都指向同一个数组的元素，或指向该数组存储空间的下一单元时才是合法的。如果指针指向一对象，我们还可以在指针上加1 从而获取指向相邻的下一个对象的指针。
	允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端位置之后或数组首地址之前的地址都是不合法的
	
	不能使用 void* 指针保存 const 对象的地址，而必须使用 const void* 类型的指针保存 const 对象的地址：
	
	不能使用指向 const 对象的指针修改基础对象，然而如果该指针指向的是一个非 const 对象，可用其他方法修改其所指的对象。不能保证指向 const 的指针所指对象的值一定不可修改。
	
	
	用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆
	对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。
	
	调用 new 动态创建长度为 0 的数组是合法的：用 new 动态创建长度为 0 的数组时，new返回有效的非零指针。该指针与new返回的其他指针不同，不能进行解引用操作，因为它毕竟没有指向任何元素。而允许的操作包括：比较运算，因此该指针能在循环中使用；在该指针上加（减）
0；或者减去本身，得 0 值。
	