using 声明的形式如下：
using namespace::name;
一旦使用了 using 声明，我们就可以直接引用名字，而不需要再引用该名字的命名空间。每个名字都需要一个 using 声明
eg:using std::cin;
     using std::string;


string 

#include <string>
using std:string;
string s1;
string s2(s1);
string s3("aaaaaa");
string s4('b',10);

string 类型的输入操作符：
? 读取并忽略开头所有的空白字符（如空格，换行符，制表符）。
? 读取字符直至再次遇到空白字符，读取终止。

getline。这个函数接受两个参数：
一个输入流对象和一个 string 对象。getline 函数从输入流的下一行读取，并保存读取的内容到不包括换行符。和输入操作符不一样的是，getline 并不忽略行开头的换行符。只要 getline 遇到换行符，即便它是输入的第一个字符，getline 也将停止读入并返回。如果第一个字符就是换行符，则 string 参数将被置为空 string。getline 函数将 istream 参数作为返回值，和输入操作符一样也把它用作判断条件.由于 getline 函数返回时丢弃换行符，换行符将不会存储在 string 对象中。

string对象的操作：
string s1;
s.empty()  如果 s 为空串，则返回 true，否则返回 false
s.size();返回 s 中字符的个数
s1=s2;把 s1 内容替换为 s2 的副本
s1+s2;把 s1 和s2 连接成一个新字符串，返回新生成的字符串
s[n];返回 s 中位置为 n 的字符，位置从 0 开始计数
v1 == v2;比较 v1 与 v2 的内容，相等则返回 true，否则返回 false
!=, <, <=, >, and >=;

任何一个大写之母都小于任意的小写字母

应该用 string::size_type 类型的变量接受 size 函数的返回值。在定义用作索引的变量时，出于同样的道理，string 对象的索引变量最好也用 string::size_type 类型。

C 标准库头文件命名形式为 name 而 C++ 版本则命名为 cname ，少了后缀，.h 而在头文件名前加了 c 表示这个头文件源自 C 标准

cctype 中的函数:
isalnum(c) 如果 c 是字母或数字，则为 True。
isalpha(c) 如果 c 是字母，则为 true。
iscntrl(c) 如果 c 是控制字符，则为 true
isdigit(c) 如果 c 是数字，则为 true。
isgraph(c) 如果 c 不是空格，但可打印，则为 true。
islower(c) 如果 c 是小写字母，则为 true。
isprint(c) 如果 c 是可打印的字符，则为 true。
ispunct(c) 如果 c 是标点符号，则 true。
isspace(c) 如果 c 是空白字符，则为 true。
isupper(c) 如果 c 是大写字母，则 true。
isxdigit(c) 如果是 c 十六进制数，则为 true。
tolower(c) 如果 c 大写字母，返回其小写字母形式，否则直接返回 c。
toupper(c) 如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c。


vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。

#include <vector>
using std::vector;


vector 不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，vector<int> 和 vector<string> 都是数据类型
初始化vector

vector<T> v1;           vector 保存类型为 T, 对象默认构造函数 v1 为空。
vector<T> v2(v1);     v2 是 v1 的一个副本。
vector<T> v3(n,i);     v3 包含 n 个值为 i 的元素。
vector<T> v4(n);       v4 含有值初始化的元素的 n 个副本

vector 对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为 vector 增长的效率高，在元素值已知的情况下，最好是动态地添加元素。


v.empty() 如果 v 为空，则返回 true，否则返回 false。
v.size() 返回 v 中元素的个数。
v.push_back(t) 在 v 的末尾增加一个值为 t 的元素。
v[n] 返回 v 中位置为 n 的元素。
v1 = v2 把 v1 的元素替换为 v2 中元素的副本。
v1 == v2 如果 v1 与 v2 相等，则返回 true。
!=, <, <=,>, and >=  保持这些操作符惯有的含义。

使用 size_type 类型时，必须指出该类型是在哪里定义的。vector 类型总是包括总是包括 vector 的元素类型：
vector<int>::size_type // ok
vector::size_type // error
下标操作不添加元素

C++ 程序员习惯于优先选用 != 而不是 < 来编写循环判断条件.调用 size 成员函数而不保存它返回的值，在这个例子中同样不是必需的，但这反映了一种良好的编程习惯。在 C++ 中，有些数据结构（如vector）可以动态增长

必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。



